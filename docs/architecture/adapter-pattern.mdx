---
title: "Adapter Pattern"
description: "How Agent Army separates core logic from runtime environments"
---

# Adapter Pattern

Agent Army uses an adapter pattern to decouple core command logic from runtime concerns. The same wizard and deployment logic works across CLI, web, and test environments.

## Architecture

```
┌─────────────────┐
│   Core Logic    │  (commands/init.ts, commands/deploy.ts, etc.)
│   (Shared)      │
└────────┬────────┘
         │ uses RuntimeAdapter
         ▼
┌────────────────────────────────────────┐
│           RuntimeAdapter               │
│  ┌──────────┐ ┌──────────┐            │
│  │ UIAdapter │ │ExecAdapter│            │
│  └──────────┘ └──────────┘            │
└────────┬───────────┬──────────────────┘
         │           │
    ┌────┴────┐ ┌────┴────┐
    │   CLI   │ │   API   │
    │ Adapter │ │ Adapter │
    └─────────┘ └─────────┘
```

## Interfaces

### UIAdapter

Handles all user interaction:

| Method | CLI Behavior | API Behavior |
|--------|-------------|-------------|
| `text()` | Prompts in terminal | Returns field descriptor |
| `select()` | Shows selection menu | Returns options list |
| `confirm()` | Yes/no prompt | Returns boolean field |
| `intro()` | Banner message | Adds to response messages |
| `log.*()` | Console output | Accumulates log entries |

### ExecAdapter

Handles command execution:

| Method | Description |
|--------|-------------|
| `capture()` | Run command, return stdout/stderr/exitCode |
| `stream()` | Run command with streaming output |
| `commandExists()` | Check if a command is available |

### RuntimeAdapter

Combines UI and Exec adapters:

```typescript
interface RuntimeAdapter {
  ui: UIAdapter;
  exec: ExecAdapter;
  platform: "cli" | "api" | "test";
}
```

## Usage

```typescript
// Core logic works with any adapter
const myTool: ToolImplementation = async (runtime, options) => {
  runtime.ui.intro("My Tool");
  const name = await runtime.ui.text({ message: "Enter name:" });
  runtime.ui.log.success(`Hello, ${name}!`);
};

// CLI context
await myTool(createCLIAdapter(), {});

// API context
const [adapter, response] = createAPIAdapter(requestBody);
await myTool(adapter, {});
res.json(response);
```

## API Adapter Flow

The API adapter uses a request/response model:

1. Client sends request with known field values
2. Adapter runs core logic, providing values from request body
3. When a field is missing, adapter throws `APIAdapterNeedsInputError`
4. Response includes field descriptors for missing inputs
5. Client re-submits with additional values

This enables progressive form completion without duplicating wizard logic.
